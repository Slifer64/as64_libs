%% Gradient Descent class
%

classdef NewtonDescent < handle
       
    methods (Access = public)
        %% Gradient Descent class constructor.
        %  @param[in] objFun_ptr: Pointer to objective function.
        %  @param[in] gradObjFun_ptr: Pointer to gradient objective function.
        %  @param[in] lineSearch: Pointer to line search object. (optinal, default = BackTrackLineSearch)
        function this = NewtonDescent(objFun_ptr, gradObjFun_ptr, hessianObjFun_ptr, lineSearch)

            if (nargin < 4), lineSearch = BackTrackLineSearch(objFun_ptr, 0.01, 0.5); end
  
            this.objFun_ptr = objFun_ptr;
            this.gradObjFun_ptr = gradObjFun_ptr;
            this.hessianObjFun_ptr = hessianObjFun_ptr;
            this.lineSearch = lineSearch;
            
            this.setMaxIters(100);
            this.setStopThreshold(1e-5);
            
            this.lowTriangSolve = dsp.LowerTriangularSolver;
            this.upperTriangSolve = dsp.UpperTriangularSolver;

        end
        
        %% Calculates the minimum based on gradient descent
        %  @param[in] x0: Initial point.
        function [x, x_data] = solve(this, x0)
            
            x = x0;
            df = this.gradObjFun_ptr(x);
            ddf = this.hessianObjFun_ptr(x);
            
            iter = 1;
            
            x_data = [];

            while (true)
                
                if (iter > this.max_iter)
                    warning('Exiting due to maximum iterations reached...');
                    break;
                end
                iter = iter + 1;
                
                if (nargout > 1), x_data = [x_data x]; end
                
                dx = - ddf\df;
                t = this.lineSearch.run(x, dx, df);
                x = x + t*dx;

                df = this.gradObjFun_ptr(x);
                ddf = this.hessianObjFun_ptr(x);

                lambda2 = -0.5*df'*dx;
                if (lambda2 < this.eps), break; end
                    
            end
            
            if (nargout > 1), x_data = [x_data x]; end

        end
        
        %% Calculates the minimum based on gradient descent
        %  @param[in] x0: Initial point.
        %  @param[in] A: Equality constrained matrix.
        %  @param[in] b: Equality constrained vector.
        %  @param[in] kkt_solve_method: Enum of type @KKTSolveMethod, specifying the method for solving the KKT system.
        %  @param[out] x: Optimal primal variable solution.
        %  @param[out] w: Optimal dual variable solution.
        %  @param[out] x_data: Matrix with the intermediate primal variable calculations (optional).
        function [x, w, x_data] = solveEq(this, x0, A, b, kkt_solve_method)
            
            if (norm(A*x0-b)/length(b) > 1e-10)
                warning('[NewtonDescent::solveEq]: The starting point needs to satisfy the equality constraints! A valid starting point will be autogenerated'); 
                x0 = A \ b;
            end
            
            m = size(A,1);
            
            if (kkt_solve_method == KKTSolveMethod.EQ_ELIM)
                [Q, R] = qr(A');
                Q1 = Q(:,1:m);
                Q2 = Q(:,m+1:end);
                R = R(1:m,:);

                this.x_hat = Q1 * this.lowTriangSolve(R',b);
                this.F = Q2;
            end
            
            % solveKKT_ptr: pointer to KKT solve function
            if (kkt_solve_method == KKTSolveMethod.FULL_INV), solveKKT_ptr = @this.solveKKTFullInv; 
            elseif (kkt_solve_method == KKTSolveMethod.BLOCK_ELIM), solveKKT_ptr = @this.solveKKTBlockElim; 
            elseif (kkt_solve_method == KKTSolveMethod.EQ_ELIM), solveKKT_ptr = @this.solveKKTEqElim; 
            else, error('[NewtonDescent::solveEq]: Unsupported KKT solve method...');
            end
            
            x = x0;
            g = this.gradObjFun_ptr(x);
            h = zeros(m,1);
            H = this.hessianObjFun_ptr(x);
            
            iter = 1;
            
            x_data = [];

            while (true)
                
                if (iter > this.max_iter)
                    warning('[NewtonDescent::solveEq]: Exiting due to maximum iterations reached...');
                    break;
                end
                iter = iter + 1;
                
                if (nargout > 2), x_data = [x_data x]; end
                
                [dx, w] = solveKKT_ptr(H, A, g, h);
              
                t = this.lineSearch.run(x, dx, g);
                x = x + t*dx;

                g = this.gradObjFun_ptr(x);
                H = this.hessianObjFun_ptr(x);

                lambda2 = 0.5*dx'*H*dx;
                if (lambda2 < this.eps), break; end
                    
            end
            
            if (nargout > 2), x_data = [x_data x]; end

        end
        
        function [x, w, x_data] = solveEqInfeasStart(this, x0, A, b, kkt_solve_method)

            m = size(A,1);
            
            if (kkt_solve_method == KKTSolveMethod.EQ_ELIM)
                error('[NewtonDescent::solveEqInfeasStart]: KKTSolveMethod.EQ_ELIM is not supported for this function.');
            end
            
            % solveKKT_ptr: pointer to KKT solve function
            if (kkt_solve_method == KKTSolveMethod.FULL_INV), solveKKT_ptr = @this.solveKKTFullInv; 
            elseif (kkt_solve_method == KKTSolveMethod.BLOCK_ELIM), solveKKT_ptr = @this.solveKKTBlockElim; 
            else, error('[NewtonDescent::solveEqInfeasStart]: Unsupported KKT solve method...');
            end
            
            x = x0;
            v = zeros(m,1);
            g = this.gradObjFun_ptr(x); 
            H = this.hessianObjFun_ptr(x);
            
            iter = 1;
            
            x_data = [];
            
            r_fun = @(x,v) norm([A*x-b; this.gradObjFun_ptr(x) + A'*v]);
            a = this.lineSearch.a;
            b = this.lineSearch.b;

            r = r_fun(x,v);
            
            while (true)
                
                if (iter > this.max_iter)
                    warning('[NewtonDescent::solveEq]: Exiting due to maximum iterations reached...');
                    break;
                end
                iter = iter + 1;
                
                if (nargout > 1), x_data = [x_data x]; end
                
                g = this.gradObjFun_ptr(x);
                H = this.hessianObjFun_ptr(x);
                
                h = Ax - b;
                [dx, dv] = solveKKT_ptr(this, H, A, g, h);
              
                % back-tracking line search
                t = 1;
                while (true)
                    r_next = r_fun(x+dx, v+dv);
                    if (r_next <= (1-a*t)*r), break; end
                    t = b*t;         
                end

                x = x + t*dx;
                v = v + t*dv;
                
                r = r_fun(x,v);

                if (norm(A*x-b)<1e-10 & r<this.eps), break; end
                    
            end
            
            if (nargout > 1), x_data = [x_data x]; end

        end
        
        
        %% Sets the stopping threshold for the solve method.
        %  @param[in] eps: Stopping threshold.
        function setStopThreshold(this, eps)
            
            this.eps = eps;
            
        end
        
        %% Sets the maximum iterations for the solve method.
        %  @param[in] max_iter: Maximum iterations.
        function setMaxIters(this, max_iter)
            
            this.max_iter = max_iter;
            
        end
        
    end
    
    methods (Access = private)
        
        %% Solves iteratively the KKT system using full inversion of the KKT matrix.
        function [dx, w] = solveKKTFullInv(this, H, A, g, h)
            
            [m, n] = size(A);
            
            z = [H A'; A zeros(m,m)] \ [-g; h];
            dx = z(1:n);
            w = z(n+1:end);
            
        end
        
        %% Solves iteratively the KKT system using variable elimination.
        function [dx, w] = solveKKTBlockElim(this, H, A, g, h)
            
            m = size(A,1);
            
%             L = chol(H,'lower');
%             temp = this.upperTriangSolve(L', this.lowTriangSolve(L,[A' g]));
            temp = H \ [A' g];
            
            invH_transA = temp(:,1:m);
            invH_g = temp(:,m+1);
            w = (A*invH_transA) \ (h - A*invH_g);

%             lowSolve = dsp.LowerTriangularSolver;
%             upSolve = dsp.UpperTriangularSolver;
%             dx = upSolve(L', lowSolve(L, (-A'*w - g) ));
            % dx = H \ (-A'*w - g);
            dx = -(invH_transA*w + invH_g);
            % dx = this.upperTriangSolve(L', this.lowTriangSolve(L, (-A'*w - g) ));

        end
        
        %% Solves iteratively the KKT system by eliminating the equality constraints and solving an unconstrained system.
        function [dx, w] = solveKKTEqElim(this, H, A, g, h)
            
            dz = (this.F'*H*this.F) \ (this.F'*g);
            dx = this.F * dz;
            w = [];

        end
        
    end
    
    properties (Access = protected)
        
        objFun_ptr         % objective function pointer
        gradObjFun_ptr     % gradient of objective function pointer
        hessianObjFun_ptr  % hessian of objective function pointer
        lineSearch         % object to lineSearch object
        
        eps      % stopping threshold
        max_iter % maximum iterations
        
        lowTriangSolve   % solver for linear equations with low triangular matrix
        upperTriangSolve % solver for linear equations with upper triangular matrix
        
        % used in solving the equality constrained problem with constraints elimination
        x_hat  % a particular solution of the equality constraints
        F      % the columns of F span the null space of the equality constraint matrix

    end
    

end

